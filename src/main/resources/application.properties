spring.application.name=Simple Trading Bot
server.port=8080
spring.data.redis.host=localhost
spring.data.redis.port=6379
#5 minutes for daily indicators (fallback)
spring.cache.redis.time-to-live=300000

# Backend API Configuration
gateway.backend.base-url=http://localhost:8080
gateway.name=Simple Trading Bot API Gateway
gateway.version=1.0.0
gateway.cors.allowed-origins=http://localhost:3000,http://localhost:8080

# Trading API Configuration
trading.binance.api.key=YOUR_BINANCE_API_KEY
trading.binance.api.secret=YOUR_BINANCE_API_SECRET

# X API Configuration (optional)
# x.api.key=YOUR_X_API_KEY
# x.api.secret=YOUR_X_API_SECRET

# OpenAPI/Swagger Documentation Configuration
springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method
springdoc.swagger-ui.tagsSorter=alpha
springdoc.swagger-ui.tryItOutEnabled=true
springdoc.show-actuator=false

# Resilience4j Configuration

# Rate Limiter Configuration for Binance API
# Binance Futures API Rate Limits:
# - Order endpoints: 100 requests per 10 seconds per IP (10 requests/second)
# - Market data endpoints: 2400 requests per minute per IP (40 requests/second)
# - Account endpoints: 180 requests per minute per IP (3 requests/second)

# Rate limiter for trading operations (orders, leverage, balance)
resilience4j.ratelimiter.instances.binance-trading.limit-for-period=8
resilience4j.ratelimiter.instances.binance-trading.limit-refresh-period=10s
resilience4j.ratelimiter.instances.binance-trading.timeout-duration=5s

# Rate limiter for market data operations (price, OHLCV)
resilience4j.ratelimiter.instances.binance-market.limit-for-period=30
resilience4j.ratelimiter.instances.binance-market.limit-refresh-period=1s
resilience4j.ratelimiter.instances.binance-market.timeout-duration=3s

# Rate limiter for account data operations
resilience4j.ratelimiter.instances.binance-account.limit-for-period=2
resilience4j.ratelimiter.instances.binance-account.limit-refresh-period=1s
resilience4j.ratelimiter.instances.binance-account.timeout-duration=5s

# Circuit Breaker Configuration
resilience4j.circuitbreaker.instances.binance-api.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.binance-api.minimum-number-of-calls=5
resilience4j.circuitbreaker.instances.binance-api.sliding-window-type=count-based
resilience4j.circuitbreaker.instances.binance-api.sliding-window-size=10
resilience4j.circuitbreaker.instances.binance-api.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.instances.binance-api.permitted-number-of-calls-in-half-open-state=3

# Retry Configuration
resilience4j.retry.instances.binance-api.max-attempts=3
resilience4j.retry.instances.binance-api.wait-duration=1s
resilience4j.retry.instances.binance-api.enable-exponential-backoff=true
resilience4j.retry.instances.binance-api.exponential-backoff-multiplier=2

# API Gateway Resilience Configuration

# Gateway Rate Limiters
resilience4j.ratelimiter.instances.gateway-trading.limit-for-period=10
resilience4j.ratelimiter.instances.gateway-trading.limit-refresh-period=1s
resilience4j.ratelimiter.instances.gateway-trading.timeout-duration=3s

resilience4j.ratelimiter.instances.gateway-resilience.limit-for-period=20
resilience4j.ratelimiter.instances.gateway-resilience.limit-refresh-period=1s
resilience4j.ratelimiter.instances.gateway-resilience.timeout-duration=2s

resilience4j.ratelimiter.instances.gateway-docs.limit-for-period=50
resilience4j.ratelimiter.instances.gateway-docs.limit-refresh-period=1s
resilience4j.ratelimiter.instances.gateway-docs.timeout-duration=2s

# Gateway Circuit Breakers
resilience4j.circuitbreaker.instances.gateway-trading.failure-rate-threshold=60
resilience4j.circuitbreaker.instances.gateway-trading.minimum-number-of-calls=5
resilience4j.circuitbreaker.instances.gateway-trading.sliding-window-size=10
resilience4j.circuitbreaker.instances.gateway-trading.wait-duration-in-open-state=30s

resilience4j.circuitbreaker.instances.gateway-resilience.failure-rate-threshold=70
resilience4j.circuitbreaker.instances.gateway-resilience.minimum-number-of-calls=3
resilience4j.circuitbreaker.instances.gateway-resilience.sliding-window-size=5
resilience4j.circuitbreaker.instances.gateway-resilience.wait-duration-in-open-state=15s

resilience4j.circuitbreaker.instances.gateway-docs.failure-rate-threshold=80
resilience4j.circuitbreaker.instances.gateway-docs.minimum-number-of-calls=3
resilience4j.circuitbreaker.instances.gateway-docs.sliding-window-size=5
resilience4j.circuitbreaker.instances.gateway-docs.wait-duration-in-open-state=10s

# Gateway Retry Configuration
resilience4j.retry.instances.gateway-trading.max-attempts=3
resilience4j.retry.instances.gateway-trading.wait-duration=500ms
resilience4j.retry.instances.gateway-trading.enable-exponential-backoff=true

resilience4j.retry.instances.gateway-resilience.max-attempts=2
resilience4j.retry.instances.gateway-resilience.wait-duration=200ms

# Kafka Configuration
spring.kafka.bootstrap-servers=localhost:9092

# PostgreSQL Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/trading_bot
spring.datasource.username=trading_user
spring.datasource.password=trading_password
spring.datasource.driver-class-name=org.postgresql.Driver

# JPA/Hibernate Configuration
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.jdbc.time_zone=UTC

# JWT Security Configuration
# IMPORTANT: Change this secret in production! Use a strong, randomly generated 256-bit (32 byte) secret
# Generate with: openssl rand -base64 32
jwt.secret=YourVerySecureSecretKeyThatIsAtLeast256BitsLong1234567890CHANGE_THIS_IN_PRODUCTION
jwt.access-token-expiration=3600000
# Access token expiration (1 hour = 3600000 milliseconds)
jwt.refresh-token-expiration=86400000
# Refresh token expiration (24 hours = 86400000 milliseconds)
jwt.issuer=simple-trading-bot

# H2 Database for Development/Testing (comment out PostgreSQL config above to use H2)
# spring.datasource.url=jdbc:h2:mem:trading_bot
# spring.datasource.driver-class-name=org.h2.Driver
# spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
# spring.h2.console.enabled=true
# spring.h2.console.path=/h2-console

spring.kafka.producer.client-id=trading-bot-producer
spring.kafka.producer.acks=all
spring.kafka.producer.retries=3
spring.kafka.producer.properties.batch.size=16384
spring.kafka.producer.properties.linger.ms=5
spring.kafka.producer.properties.buffer.memory=33554432
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer

# Kafka Consumer Configuration
spring.kafka.consumer.group-id=trading-bot
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.trusted.packages=*

# Custom Kafka Topic Configuration (used by EventTopic enum)
trading.kafka.topics.trade-signals=trading.signals
trading.kafka.topics.trade-execution=trading.executions  
trading.kafka.topics.risk-events=trading.risk
trading.kafka.topics.market-data=trading.market-data
trading.kafka.topics.bot-status=trading.bot-status

# Production Kafka Topic Partition Configuration (commented out for development)
# Uncomment and adjust these values for production deployment
# These configurations would be used with Kafka admin tools or Infrastructure as Code

# Trade Signals Topic - Medium throughput, bot-based partitioning
# trading.kafka.partitions.trade-signals=6
# trading.kafka.replication-factor.trade-signals=3

# Trade Executions Topic - Medium throughput, bot-based partitioning  
# trading.kafka.partitions.trade-executions=6
# trading.kafka.replication-factor.trade-executions=3

# Risk Events Topic - Low throughput but critical, bot-based partitioning
# trading.kafka.partitions.risk-events=3
# trading.kafka.replication-factor.risk-events=3

# Market Data Topic - High throughput, symbol-based partitioning
# trading.kafka.partitions.market-data=12
# trading.kafka.replication-factor.market-data=3

# Bot Status Topic - Low throughput, bot-based partitioning
# trading.kafka.partitions.bot-status=3  
# trading.kafka.replication-factor.bot-status=3

# Partition Strategy Notes:
# - trade-signals: 6 partitions allows up to 6 concurrent bot consumers
# - trade-executions: 6 partitions for parallel execution processing per bot
# - risk-events: 3 partitions for critical safety events, lower throughput expected
# - market-data: 12 partitions for high-frequency price updates across multiple symbols
# - bot-status: 3 partitions for status updates, typically low frequency
#
# Replication Factor: 3 recommended for production fault tolerance
# 
# Consumer Scaling: Max consumers per topic = number of partitions
# Key Distribution: Bot ID and Symbol ensure even partition distribution

# Application Lifecycle Configuration
spring.lifecycle.timeout-per-shutdown-phase=30s
server.shutdown=graceful

# Async Configuration for EventPublisher CompletableFuture
spring.task.execution.pool.core-size=4
spring.task.execution.pool.max-size=8
spring.task.execution.pool.queue-capacity=100
spring.task.execution.thread-name-prefix=trading-bot-async-

# Scheduling Configuration
spring.task.scheduling.pool.size=2
spring.task.scheduling.thread-name-prefix=trading-bot-scheduler-

# Instance Configuration
app.instance.id=${APP_INSTANCE_ID:#{T(java.util.UUID).randomUUID().toString()}}
app.instance.zone=${APP_INSTANCE_ZONE:default}
app.name=${spring.application.name:Simple Trading Bot}
app.version=@project.version@

# gRPC Server Configuration
grpc.server.port=9090
grpc.server.max-inbound-message-size=10485760
grpc.server.keep-alive-time=30s
grpc.server.keep-alive-timeout=10s
grpc.server.permit-keep-alive-without-calls=true
grpc.server.enable-reflection=true

# gRPC Client Configuration (for Gateway -> Backend communication)
grpc.client.backend.address=static://localhost:9090
grpc.client.backend.negotiation-type=PLAINTEXT
grpc.client.backend.max-inbound-message-size=10485760
grpc.client.backend.keep-alive-time=30s
grpc.client.backend.keep-alive-timeout=10s
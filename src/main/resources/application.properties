spring.application.name=Simple Trading Bot
server.port=8080
spring.data.redis.host=localhost
spring.data.redis.port=6379
#5 minutes for daily indicators (fallback)
spring.cache.redis.time-to-live=300000

# Backend API Configuration
gateway.backend.base-url=http://localhost:8080
gateway.name=Simple Trading Bot API Gateway
gateway.version=1.0.0
gateway.cors.allowed-origins=http://localhost:3000,http://localhost:8080

# Trading API Configuration
# Exchange provider: binance or bybit
trading.exchange.provider=binance

# Binance API Credentials
trading.binance.api.key=YOUR_BINANCE_API_KEY
trading.binance.api.secret=YOUR_BINANCE_API_SECRET

# Bybit API Credentials
trading.bybit.api.key=YOUR_BYBIT_API_KEY
trading.bybit.api.secret=YOUR_BYBIT_API_SECRET
# Bybit domain: MAINNET_DOMAIN (default) or TESTNET_DOMAIN
trading.bybit.domain=MAINNET_DOMAIN

# X API Configuration (optional)
# x.api.key=YOUR_X_API_KEY
# x.api.secret=YOUR_X_API_SECRET

# OpenAPI/Swagger Documentation Configuration
springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method
springdoc.swagger-ui.tagsSorter=alpha
springdoc.swagger-ui.tryItOutEnabled=true
springdoc.show-actuator=false

# Resilience4j Configuration

# Rate Limiter Configuration for Binance API
# Binance Futures API Rate Limits:
# - Order endpoints: 100 requests per 10 seconds per IP (10 requests/second)
# - Market data endpoints: 2400 requests per minute per IP (40 requests/second)
# - Account endpoints: 180 requests per minute per IP (3 requests/second)

# Rate limiter for trading operations (orders, leverage, balance)
resilience4j.ratelimiter.instances.binance-trading.limit-for-period=8
resilience4j.ratelimiter.instances.binance-trading.limit-refresh-period=10s
resilience4j.ratelimiter.instances.binance-trading.timeout-duration=5s

# Rate limiter for market data operations (price, OHLCV)
resilience4j.ratelimiter.instances.binance-market.limit-for-period=30
resilience4j.ratelimiter.instances.binance-market.limit-refresh-period=1s
resilience4j.ratelimiter.instances.binance-market.timeout-duration=3s

# Rate limiter for account data operations
resilience4j.ratelimiter.instances.binance-account.limit-for-period=2
resilience4j.ratelimiter.instances.binance-account.limit-refresh-period=1s
resilience4j.ratelimiter.instances.binance-account.timeout-duration=5s

# Circuit Breaker Configuration
resilience4j.circuitbreaker.instances.binance-api.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.binance-api.minimum-number-of-calls=5
resilience4j.circuitbreaker.instances.binance-api.sliding-window-type=count-based
resilience4j.circuitbreaker.instances.binance-api.sliding-window-size=10
resilience4j.circuitbreaker.instances.binance-api.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.instances.binance-api.permitted-number-of-calls-in-half-open-state=3

# Rate Limiter Configuration for Bybit API
# Bybit V5 API Rate Limits:
# - Trading endpoints: 10 requests per second
# - Market data endpoints: 50 requests per second  
# - Account endpoints: 5 requests per second

# Rate limiter for trading operations (orders, leverage)
resilience4j.ratelimiter.instances.bybit-trading.limit-for-period=8
resilience4j.ratelimiter.instances.bybit-trading.limit-refresh-period=1s
resilience4j.ratelimiter.instances.bybit-trading.timeout-duration=5s

# Rate limiter for market data operations (price, OHLCV)
resilience4j.ratelimiter.instances.bybit-market.limit-for-period=40
resilience4j.ratelimiter.instances.bybit-market.limit-refresh-period=1s
resilience4j.ratelimiter.instances.bybit-market.timeout-duration=3s

# Rate limiter for account data operations
resilience4j.ratelimiter.instances.bybit-account.limit-for-period=4
resilience4j.ratelimiter.instances.bybit-account.limit-refresh-period=1s
resilience4j.ratelimiter.instances.bybit-account.timeout-duration=5s

# Circuit Breaker Configuration for Bybit
resilience4j.circuitbreaker.instances.bybit-api.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.bybit-api.minimum-number-of-calls=5
resilience4j.circuitbreaker.instances.bybit-api.sliding-window-type=count-based
resilience4j.circuitbreaker.instances.bybit-api.sliding-window-size=10
resilience4j.circuitbreaker.instances.bybit-api.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.instances.bybit-api.permitted-number-of-calls-in-half-open-state=3

# Retry Configuration
resilience4j.retry.instances.bybit-trading.max-attempts=3
resilience4j.retry.instances.bybit-trading.wait-duration=500ms
resilience4j.retry.instances.bybit-trading.enable-exponential-backoff=true

resilience4j.retry.instances.bybit-market.max-attempts=2
resilience4j.retry.instances.bybit-market.wait-duration=200ms

resilience4j.retry.instances.bybit-account.max-attempts=3
resilience4j.retry.instances.bybit-account.wait-duration=500ms

# Retry Configuration
resilience4j.retry.instances.binance-api.max-attempts=3
resilience4j.retry.instances.binance-api.wait-duration=1s
resilience4j.retry.instances.binance-api.enable-exponential-backoff=true
resilience4j.retry.instances.binance-api.exponential-backoff-multiplier=2

# API Gateway Resilience Configuration

# Gateway Rate Limiters
resilience4j.ratelimiter.instances.gateway-trading.limit-for-period=10
resilience4j.ratelimiter.instances.gateway-trading.limit-refresh-period=1s
resilience4j.ratelimiter.instances.gateway-trading.timeout-duration=3s

resilience4j.ratelimiter.instances.gateway-resilience.limit-for-period=20
resilience4j.ratelimiter.instances.gateway-resilience.limit-refresh-period=1s
resilience4j.ratelimiter.instances.gateway-resilience.timeout-duration=2s

resilience4j.ratelimiter.instances.gateway-docs.limit-for-period=50
resilience4j.ratelimiter.instances.gateway-docs.limit-refresh-period=1s
resilience4j.ratelimiter.instances.gateway-docs.timeout-duration=2s

# Gateway Authentication Rate Limiter (Stricter for security)
# 10 authentication requests per minute to prevent brute force attacks
resilience4j.ratelimiter.instances.gateway-auth.limit-for-period=10
resilience4j.ratelimiter.instances.gateway-auth.limit-refresh-period=60s
resilience4j.ratelimiter.instances.gateway-auth.timeout-duration=0s

# Gateway Circuit Breakers
resilience4j.circuitbreaker.instances.gateway-trading.failure-rate-threshold=60
resilience4j.circuitbreaker.instances.gateway-trading.minimum-number-of-calls=5
resilience4j.circuitbreaker.instances.gateway-trading.sliding-window-size=10
resilience4j.circuitbreaker.instances.gateway-trading.wait-duration-in-open-state=30s

resilience4j.circuitbreaker.instances.gateway-resilience.failure-rate-threshold=70
resilience4j.circuitbreaker.instances.gateway-resilience.minimum-number-of-calls=3
resilience4j.circuitbreaker.instances.gateway-resilience.sliding-window-size=5
resilience4j.circuitbreaker.instances.gateway-resilience.wait-duration-in-open-state=15s

resilience4j.circuitbreaker.instances.gateway-docs.failure-rate-threshold=80
resilience4j.circuitbreaker.instances.gateway-docs.minimum-number-of-calls=3
resilience4j.circuitbreaker.instances.gateway-docs.sliding-window-size=5
resilience4j.circuitbreaker.instances.gateway-docs.wait-duration-in-open-state=10s

# Gateway Authentication Circuit Breaker (Critical service)
# Opens circuit after 50% failure rate to protect auth service
resilience4j.circuitbreaker.instances.gateway-auth.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.gateway-auth.minimum-number-of-calls=5
resilience4j.circuitbreaker.instances.gateway-auth.sliding-window-size=10
resilience4j.circuitbreaker.instances.gateway-auth.wait-duration-in-open-state=60s

# Gateway Retry Configuration
resilience4j.retry.instances.gateway-trading.max-attempts=3
resilience4j.retry.instances.gateway-trading.wait-duration=500ms
resilience4j.retry.instances.gateway-trading.enable-exponential-backoff=true

resilience4j.retry.instances.gateway-resilience.max-attempts=2
resilience4j.retry.instances.gateway-resilience.wait-duration=200ms

# Gateway Authentication Retry Configuration
# Only retry on network errors, not on auth failures (401)
resilience4j.retry.instances.gateway-auth.max-attempts=2
resilience4j.retry.instances.gateway-auth.wait-duration=500ms

# Kafka Configuration (disabled for testing - not required for paper trading)
# spring.kafka.bootstrap-servers=localhost:9092

# PostgreSQL Database Configuration (commented out for testing)
# spring.datasource.url=jdbc:postgresql://localhost:5432/trading_bot
# spring.datasource.username=tradingbot
# spring.datasource.password=tradingbot123
# spring.datasource.driver-class-name=org.postgresql.Driver

# HikariCP Connection Pool Configuration
# spring.datasource.hikari.maximum-pool-size=10
# spring.datasource.hikari.minimum-idle=5
# spring.datasource.hikari.connection-timeout=30000
# spring.datasource.hikari.idle-timeout=600000
# spring.datasource.hikari.max-lifetime=1800000

# JPA/Hibernate Configuration
# spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
# spring.jpa.hibernate.ddl-auto=update
# spring.jpa.show-sql=false
# spring.jpa.properties.hibernate.format_sql=true
# spring.jpa.properties.hibernate.jdbc.time_zone=UTC

# JWT Security Configuration
# IMPORTANT: Change this secret in production! Use a strong, randomly generated 256-bit (32 byte) secret
# Generate with: openssl rand -base64 32
jwt.secret=YourVerySecureSecretKeyThatIsAtLeast256BitsLong1234567890CHANGE_THIS_IN_PRODUCTION
jwt.access-token-expiration=3600000
# Access token expiration (1 hour = 3600000 milliseconds)
jwt.refresh-token-expiration=86400000
# Refresh token expiration (24 hours = 86400000 milliseconds)
jwt.issuer=simple-trading-bot

# H2 Database for Development/Testing (enabled for testing)
spring.datasource.url=jdbc:h2:mem:trading_bot
spring.datasource.driver-class-name=org.h2.Driver
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=create-drop
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

spring.kafka.producer.client-id=trading-bot-producer
spring.kafka.producer.acks=all
spring.kafka.producer.retries=3
spring.kafka.producer.properties.batch.size=16384
spring.kafka.producer.properties.linger.ms=5
spring.kafka.producer.properties.buffer.memory=33554432
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer

# Kafka Consumer Configuration
spring.kafka.consumer.group-id=trading-bot
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.trusted.packages=*

# Custom Kafka Topic Configuration (used by EventTopic enum)
trading.kafka.topics.trade-signals=trading.signals
trading.kafka.topics.trade-execution=trading.executions  
trading.kafka.topics.risk-events=trading.risk
trading.kafka.topics.market-data=trading.market-data
trading.kafka.topics.bot-status=trading.bot-status

# Production Kafka Topic Partition Configuration (commented out for development)
# Uncomment and adjust these values for production deployment
# These configurations would be used with Kafka admin tools or Infrastructure as Code

# Trade Signals Topic - Medium throughput, bot-based partitioning
# trading.kafka.partitions.trade-signals=6
# trading.kafka.replication-factor.trade-signals=3

# Trade Executions Topic - Medium throughput, bot-based partitioning  
# trading.kafka.partitions.trade-executions=6
# trading.kafka.replication-factor.trade-executions=3

# Risk Events Topic - Low throughput but critical, bot-based partitioning
# trading.kafka.partitions.risk-events=3
# trading.kafka.replication-factor.risk-events=3

# Market Data Topic - High throughput, symbol-based partitioning
# trading.kafka.partitions.market-data=12
# trading.kafka.replication-factor.market-data=3

# Bot Status Topic - Low throughput, bot-based partitioning
# trading.kafka.partitions.bot-status=3  
# trading.kafka.replication-factor.bot-status=3

# Partition Strategy Notes:
# - trade-signals: 6 partitions allows up to 6 concurrent bot consumers
# - trade-executions: 6 partitions for parallel execution processing per bot
# - risk-events: 3 partitions for critical safety events, lower throughput expected
# - market-data: 12 partitions for high-frequency price updates across multiple symbols
# - bot-status: 3 partitions for status updates, typically low frequency
#
# Replication Factor: 3 recommended for production fault tolerance
# 
# Consumer Scaling: Max consumers per topic = number of partitions
# Key Distribution: Bot ID and Symbol ensure even partition distribution

# Application Lifecycle Configuration
spring.lifecycle.timeout-per-shutdown-phase=30s
server.shutdown=graceful

# Async Configuration for EventPublisher CompletableFuture
spring.task.execution.pool.core-size=4
spring.task.execution.pool.max-size=8
spring.task.execution.pool.queue-capacity=100
spring.task.execution.thread-name-prefix=trading-bot-async-

# Scheduling Configuration
spring.task.scheduling.pool.size=2
spring.task.scheduling.thread-name-prefix=trading-bot-scheduler-

# Instance Configuration
app.instance.id=${APP_INSTANCE_ID:#{T(java.util.UUID).randomUUID().toString()}}
app.instance.zone=${APP_INSTANCE_ZONE:default}
app.name=${spring.application.name:Simple Trading Bot}
app.version=@project.version@

# gRPC Server Configuration
grpc.server.port=9090
grpc.server.max-inbound-message-size=10485760
grpc.server.keep-alive-time=30s
grpc.server.keep-alive-timeout=10s
grpc.server.permit-keep-alive-without-calls=true
grpc.server.enable-reflection=true
grpc.server.security.enabled=false

# gRPC Client Configuration (for Gateway -> Backend communication)
grpc.client.backend.address=static://localhost:9090
grpc.client.backend.negotiation-type=PLAINTEXT
grpc.client.backend.max-inbound-message-size=10485760
grpc.client.backend.keep-alive-time=30s
grpc.client.backend.keep-alive-timeout=10s

# Agentic AI Configuration

# Agent Orchestrator Configuration
agent.orchestrator.loop-interval=30000
# Agent loop execution interval (30 seconds = 30000 milliseconds)
agent.orchestrator.enabled=true
# Enable/disable autonomous agent loop execution

# Grok LLM Configuration (X.AI)
agent.llm.provider=grok
agent.llm.grok.api-key=${GROK_API_KEY:}
# Set GROK_API_KEY environment variable with your X.AI API key
agent.llm.grok.api-url=https://api.x.ai/v1/chat/completions
agent.llm.grok.model=grok-beta
agent.llm.grok.temperature=0.7
# Higher temperature = more creative, lower = more conservative
agent.llm.grok.max-tokens=2000
# Maximum tokens in LLM response
agent.llm.grok.timeout=30s
# Request timeout for LLM API calls
agent.llm.grok.enabled=${agent.orchestrator.enabled:true}
# Grok provider enabled by default when orchestrator is enabled

# RAG (Retrieval-Augmented Generation) Configuration

# RAG System Enable/Disable
rag.enabled=true
# Set to false to use traditional LLM without memory retrieval

# OpenAI Embedding Configuration
openai.api.key=${OPENAI_API_KEY:}
# Set OPENAI_API_KEY environment variable for OpenAI embeddings

# Embedding Provider Configuration
rag.embedding.provider=openai
# Options: openai (recommended), grok (experimental - uses hash-based approach)
# Note: Grok embeddings use a hybrid approach since X.AI doesn't have native embeddings API yet
#       Consider using openai for better quality or waiting for X.AI embeddings release

rag.embedding.model=text-embedding-3-small
# OpenAI embedding model (1536 dimensions)
rag.embedding.dimensions=1536
# Number of dimensions in embedding vectors

# Vector Database Configuration
rag.vector-db.provider=pinecone
# Options: pinecone, weaviate, qdrant
rag.vector-db.api-key=${PINECONE_API_KEY:}
# Set PINECONE_API_KEY environment variable
rag.vector-db.environment=${PINECONE_ENVIRONMENT:us-east-1-aws}
# Pinecone environment/region
rag.vector-db.index-name=trading-memories
# Vector database index name
rag.vector-db.namespace=default
# Namespace for isolating data (e.g., per agent or symbol)

# RAG Retrieval Configuration
rag.retrieval.top-k=5
# Number of similar memories to retrieve
rag.retrieval.similarity-threshold=0.7
# Minimum similarity score (0-1) to include a memory
rag.retrieval.max-age-days=90
# Only retrieve memories from last N days (0 = no limit)

# Order Placement Configuration
rag.order.confidence-threshold=60
# Minimum confidence percentage to place an order (0-100)
rag.order.enabled=true
# Enable/disable autonomous order placement
rag.order.dry-run=true
# If true, log orders but don't execute on exchange
rag.order.max-position-size-percent=10
# Maximum position size as % of account balance
rag.order.default-leverage=1
# Default leverage for futures trading (1-125, use with caution)